package main

import (
	"flag"
	"fmt"

	"github.com/dapperlabs/proto-gen-go-grpc-scopes/scopesproto"
	"github.com/golang/protobuf/proto"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	var (
		flags flag.FlagSet
	)

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			msgScopesInfo := map[string][]string{}
			for _, msg := range f.Messages {
				msgName := msg.GoIdent.GoName
				msgOptions := msg.Desc.Options()
				if msgOptions == nil {
					continue
				}
				msgOptionsPB := msgOptions.(*descriptorpb.MessageOptions)
				ext, err := proto.GetExtension(msgOptionsPB, scopesproto.E_RequiredReqScopes)
				if err != nil {
					// not a scope extension
					continue
				}
				scopesExt := ext.(*scopesproto.RequiredScopesOption)
				msgScopesInfo[msgName] = scopesExt.Scopes
			}

			if len(msgScopesInfo) > 0 {
				// generate scopes file
				filename := f.GeneratedFilenamePrefix + "_scopes.pb.go"
				g := gen.NewGeneratedFile(filename, f.GoImportPath)
				g.P("// Code generated by protoc-gen-go-scopes. DO NOT EDIT.")
				g.P("package ", f.GoPackageName)
				for msg, requiredScopes := range msgScopesInfo {
					g.P(fmt.Sprintf("func (*%s) RequiredScopes() []string {", msg))
					g.P(fmt.Sprintf("return %#v", requiredScopes))
					g.P("}")
				}
			}
		}
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		return nil
	})
}
